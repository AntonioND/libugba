// SPDX-License-Identifier: MIT
//
// Copyright (c) 2021 Antonio Niño Díaz

// Basic template for a project using UGBA (and UMOD Player).

#include <stdio.h>
#include <string.h>

#include <ugba/ugba.h>

#include <umod/umod.h>

#include "umod_pack_bin.h"
#include "umod_pack_info.h"

#include "random_bin.h"

#include "city.h" // Autogenerated from city.png

#define CITY_MAP_PALETTE    (0)
#define CITY_TILES_BASE     MEM_BG_TILES_BLOCK_ADDR(0)
#define CITY_MAP_BASE       MEM_BG_MAP_BLOCK_ADDR(8)

// Buffer size needs to be a multiple of 16 (the amount of bytes copied to the
// FIFO whenever it gets data from DMA).
//
// Timer Reload = Clocks per frame / buffer size = 280896 / buffer size
// It needs to be an exact division.
//
// Sample rate = Buffer size * FPS = Buffer size * CPU Freq / Clocks per frame
// Sample rate = (Buffer size * 16 * 1024 * 1024) / 280896
//
// Valid combinations:
//
// Sample Rate | Timer Reload | Buffer Size
// ------------+--------------+------------
// 10512.04    | 1596         | 176
// 13378.96    | 1254         | 224
// 18157.16    | 924          | 304
// 21024.08    | 798          | 352
// 26757.92    | 627          | 448
// 31536.12    | 532          | 528
// 36314.32    | 462          | 608
// 40136.88    | 418          | 672

#define SAMPLE_RATE         31536

#define TICKS_PER_RELOAD    532
#define RELOAD_VALUE        (65536 - TICKS_PER_RELOAD)

#define BUFFER_SIZE         528

#define DMA_TIMER_INDEX     0 // Timer 0 controls the transfer rate of DMA A/B

static int current_dma_buffer = 0;

ALIGNED(32) int8_t wave_a[BUFFER_SIZE * 2];
ALIGNED(32) int8_t wave_b[BUFFER_SIZE * 2];

IWRAM_CODE ARM_CODE void vbl_handler(void)
{
    // The buffer swap needs to be done right at the beginning of the VBL
    // interrupt handler so that the timing is always the same in each frame.

    if (current_dma_buffer == 0)
        SOUND_DMA_Retrigger_AB();
}

int main(int argc, char *argv[])
{
    UGBA_Init(&argc, &argv);

    IRQ_SetHandler(IRQ_VBLANK, vbl_handler);
    IRQ_Enable(IRQ_VBLANK);

    // Load background
    // ===============

    // Load the palette
    VRAM_BGPalette16Copy(cityPal, cityPalLen, CITY_MAP_PALETTE);

    // Load the tiles
    SWI_CpuSet_Copy16(cityTiles, (void *)CITY_TILES_BASE, cityTilesLen);

    // Load the map
    SWI_CpuSet_Copy16(cityMap, (void *)CITY_MAP_BASE, cityMapLen);

    // Setup background
    BG_RegularInit(0, BG_REGULAR_512x512, BG_16_COLORS,
                   CITY_TILES_BASE, CITY_MAP_BASE);

    int x = 80, y = 120;
    BG_RegularScrollSet(0, x, y);

    // Set the display to mode 0 so that all backgrounds are in regular mode,
    // and turn on background 0.
    DISP_ModeSet(0);
    DISP_LayersEnable(1, 0, 0, 0, 0);

    // Start music
    // ===========

    UMOD_Init(SAMPLE_RATE);
    UMOD_LoadPack(umod_pack_bin);

    // The sound hardware needs to be enabled to write to any other register.
    SOUND_MasterEnable(1);
    SOUND_DMA_Volume(100, 100);
    SOUND_DMA_Pan(1, 0, 0, 1); // DMA A to the left, DMA B to the right

    SOUND_DMA_TimerSetup(DMA_TIMER_INDEX, DMA_TIMER_INDEX);
    TM_TimerStop(DMA_TIMER_INDEX);
    TM_TimerStart(DMA_TIMER_INDEX, RELOAD_VALUE, 1, 0);

    SOUND_DMA_Setup_AB(wave_a, wave_b);

    UMOD_Song_Play(SONG_KAOS_OCH_DEKADENS_MOD);

    while (1)
    {
        if (current_dma_buffer == 1)
            UMOD_Mix(wave_a, wave_b, BUFFER_SIZE);
        else
            UMOD_Mix(&wave_a[BUFFER_SIZE], &wave_b[BUFFER_SIZE], BUFFER_SIZE);

        current_dma_buffer ^= 1;

        SWI_VBlankIntrWait();

        KEYS_Update();

        uint16_t keys = KEYS_Held();

        BG_RegularScrollGet(0, &x, &y);

        if (keys & KEY_UP)
            y--;
        else if (keys & KEY_DOWN)
            y++;

        if (keys & KEY_RIGHT)
            x++;
        else if (keys & KEY_LEFT)
            x--;

        BG_RegularScrollSet(0, x, y);
    }

    return 0;
}
